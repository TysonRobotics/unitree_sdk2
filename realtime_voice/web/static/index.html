<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Robot Voice Control</title>
  <style>
    html, body { width: 100%; max-width: 100%; overflow-x: hidden; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 16px; line-height: 1.4; }
    h1 { margin-top: 0; font-size: clamp(18px, 3vw, 28px); }
    .row { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px; }
    button { padding: 10px 14px; font-size: clamp(14px, 2vw, 18px); cursor: pointer; }
    .toggle { background: #eee; }
    .danger { background: #f8d7da; }
    .ok { background: #d1e7dd; }
    .card { border: 1px solid #ddd; padding: 12px; border-radius: 8px; max-width: 100%; width: 100%; box-sizing: border-box; }
    input[type="range"] { width: 240px; max-width: 100%; }
    input, select { max-width: 100%; }
    label { display: inline-block; width: 120px; }
    .sb-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; width: 100%; }
    .sb-cell button { width: 100%; min-height: clamp(48px, 8vw, 72px); }
    .spectro-container { display: flex; gap: 12px; flex-wrap: wrap; }
    .spectro-box { flex: 1; min-width: 280px; border: 1px solid #ccc; border-radius: 8px; padding: 8px; }
    .spectro-canvas { width: 100%; height: 200px; background: #000; }
    .param-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 12px; }
    .param-box { border: 1px solid #ddd; padding: 8px; border-radius: 4px; }
    .param-box label { display: block; margin-bottom: 4px; font-size: 14px; }
    .param-box input[type="range"] { width: 100%; }

    /* Responsive improvements */
    @media (max-width: 900px) {
      .card { max-width: 100%; }
      input[type="range"] { width: 100%; }
    }
    @media (max-width: 600px) {
      .row { flex-direction: column; align-items: stretch; gap: 6px; }
      label { width: auto; }
      button { width: 100%; }
      .sb-cell button { min-height: 48px; }
    }
  </style>
  <script>
    async function post(url, body) {
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: body ? JSON.stringify(body) : '{}'
      });
      return res.json();
    }
    async function mute(val) {
      await post('/api/mute', { value: val });
    }
    async function toggleMute() {
      await post('/api/toggle_mute');
    }
    async function stopSpeak() {
      await post('/api/stop');
    }
    async function reloadAll() {
      await post('/api/reload');
    }
    async function setVolume(val) {
      document.getElementById('volLabel').innerText = val + '%';
      await post('/api/volume', { value: parseInt(val) });
    }
    async function volumeUp() { await post('/api/volume_up'); }
    async function volumeDown() { await post('/api/volume_down'); }
    async function setBargeIn(val) { await post('/api/barge_in', { value: val }); }

    async function refreshRecordings() {
      const res = await fetch('/api/recordings');
      const data = await res.json();
      const list = document.getElementById('recList');
      if (!list) return;
      list.innerHTML = '';
      if (data && data.files) {
        for (const f of data.files) {
          const li = document.createElement('li');
          li.textContent = f + ' ';
          const btn = document.createElement('button');
          btn.textContent = 'Play';
          btn.onclick = async () => { await post('/api/play', { file: f }); };
          li.appendChild(btn);
          list.appendChild(li);
        }
      }
    }
    async function recordStart() {
      const el = document.getElementById('recName');
      const name = el ? (el.value || '').trim() : '';
      await post('/api/record_start', name ? { name } : {});
    }
    async function recordStop() {
      await post('/api/record_stop');
      await refreshRecordings();
    }
    window.addEventListener('load', refreshRecordings);
    window.addEventListener('load', sbLoad);
    window.addEventListener('load', voiceLoad);

    async function uploadWav() {
      const fi = document.getElementById('uploadFile');
      if (!fi || !fi.files || fi.files.length === 0) return;
      const file = fi.files[0];
      const fd = new FormData();
      fd.append('file', file);
      const res = await fetch('/api/upload', { method: 'POST', body: fd });
      try { await res.json(); } catch (e) {}
      await refreshRecordings();
      fi.value = '';
    }

    
    async function sbLoad(desiredProfile) {
      const res = await fetch('/api/soundboard');
      const data = await res.json();
      const sel = document.getElementById('sbProfile');
      const grid = document.getElementById('sbGrid');
      const files = data.recordings || [];
      const cfg = data.config || { profiles: { Default: [] }, slot_count: 16 };
      // Fill profile select
      const prev = desiredProfile || (sel ? sel.value : '') || localStorage.getItem('sbProfile') || '';
      sel.innerHTML = '';
      const profNames = Object.keys(cfg.profiles || {});
      for (const p of profNames) {
        const opt = document.createElement('option');
        opt.value = p; opt.textContent = p; sel.appendChild(opt);
      }
      // Choose selection: desired -> prev -> first
      if (prev && profNames.includes(prev)) {
        sel.value = prev;
      } else if (!sel.value && sel.options && sel.options.length) {
        sel.value = sel.options[0].value;
      }

      // If no profiles at all, create Default then reload
      if ((!profNames || profNames.length === 0)) {
        await fetch('/api/soundboard/profile', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ profile: 'Default' })
        });
        return sbLoad('Default');
      }
      // Render grid
      grid.innerHTML = '';
      const slots = cfg.profiles[sel.value] || [];
      const count = cfg.slot_count || 16;
      for (let i = 0; i < count; i++) {
        const slotFile = slots[i] || '';
        const cell = document.createElement('div');
        cell.className = 'sb-cell';
        const btn = document.createElement('button');
        btn.textContent = slotFile || `Slot ${i+1}`;
        btn.onclick = async () => { await post('/api/soundboard/play', { profile: sel.value, index: i }); };
        cell.appendChild(btn);
        // edit controls
        const row = document.createElement('div');
        row.className = 'row';
        const pick = document.createElement('select');
        const empty = document.createElement('option'); empty.value=''; empty.textContent='(empty)'; pick.appendChild(empty);
        for (const f of files) { const o=document.createElement('option'); o.value=f; o.textContent=f; pick.appendChild(o);} 
        pick.value = slotFile;
        pick.onchange = () => { btn.textContent = pick.value || `Slot ${i+1}`; btn.dataset.file = pick.value; };
        row.appendChild(pick);
        cell.appendChild(row);
        grid.appendChild(cell);
      }
      localStorage.setItem('sbProfile', sel.value);
    }

    async function sbSave() {
      const sel = document.getElementById('sbProfile');
      const grid = document.getElementById('sbGrid');
      const picks = grid.querySelectorAll('select');
      const slots = Array.from(picks).map(s => s.value || null);
      await post('/api/soundboard/save', { profile: sel.value, slots });
    }

    function sbAddProfile() {
      const sel = document.getElementById('sbProfile');
      const name = prompt('New profile name');
      if (!name) return;
      fetch('/api/soundboard/profile', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ profile: name })
      }).then(r=>r.json()).then(_ => sbLoad(name));
    }

    // Voice tab logic
    async function voiceLoad() {
      try {
        const res = await fetch('/api/voice');
        const data = await res.json();
        const presetSel = document.getElementById('voicePreset');
        const personaEl = document.getElementById('voicePersona');
        const factsEl = document.getElementById('voiceFacts');
        // Fill textareas
        personaEl.value = data.persona || '';
        factsEl.value = data.facts || '';
        // Fill preset dropdown
        presetSel.innerHTML = '';
        (data.presets || []).forEach(p => {
          const o = document.createElement('option');
          o.value = p; o.textContent = p; presetSel.appendChild(o);
        });
      } catch (e) {
        // ignore
      }
    }

    async function voiceSave() {
      const personaEl = document.getElementById('voicePersona');
      const factsEl = document.getElementById('voiceFacts');
      await fetch('/api/voice/save', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ persona: personaEl.value || '', facts: factsEl.value || '' })
      });
      // Reload the running client to pick up changes immediately
      await fetch('/api/reload', { method: 'POST' });
    }

    async function voiceApplyPreset() {
      const presetSel = document.getElementById('voicePreset');
      const name = presetSel.value;
      if (!name) return;
      await fetch('/api/voice/preset', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name })
      });
      await voiceLoad();
      // Reload the running client so preset takes effect immediately
      await fetch('/api/reload', { method: 'POST' });
    }

    async function audioReset() {
      try {
        const res = await fetch('/api/audio_reset', { method: 'POST' });
        const data = await res.json();
        console.log('Audio reset:', data);
      } catch (e) {
        console.error('Audio reset failed:', e);
      }
    }

    function showTab(tabId) {
      ['tabMain', 'tabSB', 'tabVoice', 'tabControls'].forEach(id => {
        document.getElementById(id).style.display = id === tabId ? 'block' : 'none';
      });
    }

    async function setParam(param, value) {
      await fetch('/api/set_param', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ param, value: parseFloat(value) })
      });
    }

    let vizSocket = null;
    let micData = { level: 0, spectrum: [], freq_labels: [] };
    let spkData = { level: 0, spectrum: [], freq_labels: [] };
    let micHistory = [];
    let spkHistory = [];
    const maxHistoryFrames = 100; // 5 seconds at 20 FPS

    function controlsLoad() {
      // Set default VAD mode UI (server is default)
      setVadModeUI('server');
      
      // Start polling for audio data and drawing spectrogram
      const canvas = document.getElementById('micSpectro');
      if (canvas) {
        startAudioPolling();
        setInterval(() => {
          drawMicSpectrogram(canvas);
        }, 100); // 10 FPS
      }
    }

    function startAudioPolling() {
      setInterval(async () => {
        try {
          const res = await fetch('/api/audio_viz');
          const data = await res.json();
          if (data.ok && data.data) {
            micData = data.data;
            // Add to history for waterfall
            if (micData.mic_spectrum && micData.mic_spectrum.length > 0) {
              micHistory.push(micData.mic_spectrum);
              if (micHistory.length > maxHistoryFrames) micHistory.shift();
            }
          }
        } catch (e) {}
      }, 100); // 10 Hz polling
    }

    function drawMicSpectrogram(canvas) {
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      
      // Clear
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, w, h);
      
      if (!micData || !micData.mic_spectrum) return;
      
      const spectrum = micData.mic_spectrum;
      const level = micData.mic_level || 0;
      const speaking = micData.vad_speaking || false;
      const startGate = micData.start_gate || 0.01;
      const stopGate = micData.stop_gate || 0.01;
      const sampleRate = micData.sample_rate || 48000;
      
      // Layout: left = freq labels, center = waterfall, right = current spectrum + level
      const labelWidth = 60;
      const spectroWidth = w - 140;
      const barWidth = 60;
      const spectroHeight = h - 40;
      
      // Draw waterfall (time history)
      micHistory.forEach((frame, timeIdx) => {
        const x = labelWidth + (timeIdx / maxHistoryFrames) * spectroWidth;
        const timeWidth = Math.max(1, spectroWidth / maxHistoryFrames);
        frame.forEach((val, freqIdx) => {
          if (val > 0.05) {
            const y = spectroHeight - (freqIdx / frame.length) * spectroHeight;
            const freqHeight = Math.max(1, spectroHeight / frame.length);
            const intensity = Math.min(255, val * 255);
            ctx.fillStyle = `rgba(0, ${intensity}, 0, 0.8)`;
            ctx.fillRect(x, y, timeWidth, freqHeight);
          }
        });
      });
      
      // Draw current spectrum bars
      const barX = labelWidth + spectroWidth + 10;
      spectrum.forEach((val, i) => {
        const barY = spectroHeight - (i / spectrum.length) * spectroHeight;
        const barHeight = Math.max(1, spectroHeight / spectrum.length);
        const intensity = Math.min(255, val * 255);
        ctx.fillStyle = `rgba(0, ${intensity}, 0, 0.9)`;
        ctx.fillRect(barX, barY, 40, barHeight);
      });
      
      // Draw level meter
      ctx.fillStyle = speaking ? '#0f0' : '#080';
      const levelHeight = Math.min(spectroHeight, level * spectroHeight * 20);
      ctx.fillRect(barX + 45, spectroHeight - levelHeight, 10, levelHeight);
      
      // Draw VAD thresholds
      ctx.strokeStyle = '#f00';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]);
      const startY = spectroHeight - (startGate * spectroHeight * 20);
      const stopY = spectroHeight - (stopGate * spectroHeight * 20);
      ctx.beginPath();
      ctx.moveTo(labelWidth, startY); ctx.lineTo(barX + 55, startY);
      ctx.moveTo(labelWidth, stopY); ctx.lineTo(barX + 55, stopY);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Frequency labels
      ctx.fillStyle = '#ccc';
      ctx.font = '10px monospace';
      const freqStep = Math.max(1, Math.floor(spectrum.length / 6));
      for (let i = 0; i < spectrum.length; i += freqStep) {
        const freq = (i + 1) * (sampleRate / 2) / spectrum.length;
        const y = spectroHeight - (i / spectrum.length) * spectroHeight;
        const label = freq < 1000 ? `${freq.toFixed(0)}Hz` : `${(freq/1000).toFixed(1)}k`;
        ctx.fillText(label, 5, y + 5);
      }
      
      // Labels and status
      ctx.fillStyle = '#fff';
      ctx.font = '12px monospace';
      ctx.fillText('Microphone Input', 5, 15);
      ctx.fillText(`Level: ${level.toFixed(4)}`, 5, h - 25);
      ctx.fillText(`Speaking: ${speaking ? 'YES' : 'NO'}`, 120, h - 25);
      ctx.fillText(`Mode: ${micData.vad_mode || 'server'}`, 250, h - 25);
      ctx.fillText('Time →', spectroWidth / 2, h - 5);
      ctx.fillText('Now', barX + 15, h - 5);
    }

    function drawSpectrogram(canvas, data, label, color) {
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      
      // Clear
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, w, h);
      
      const spectrum = data.spectrum || [];
      const history = label.includes('Microphone') ? micHistory : spkHistory;
      
      if (spectrum.length > 0) {
        // Draw waterfall spectrogram (time scrolling)
        const spectroHeight = h - 60; // Leave space for labels and level
        const spectroWidth = w - 80;   // Leave space for freq labels and level meter
        
        // Draw historical spectrum as waterfall
        history.forEach((frame, timeIdx) => {
          const x = 60 + (timeIdx / maxHistoryFrames) * spectroWidth;
          frame.forEach((val, freqIdx) => {
            if (val > 0.1) { // Only draw significant values
              const y = spectroHeight - (freqIdx / frame.length) * spectroHeight;
              const intensity = Math.min(255, val * 255);
              ctx.fillStyle = `rgba(${color === '#0f0' ? intensity + ',255,0' : '255,' + intensity + ',0'}, 0.8)`;
              ctx.fillRect(x, y, Math.max(1, spectroWidth / maxHistoryFrames), Math.max(1, spectroHeight / frame.length));
            }
          });
        });
        
        // Draw current spectrum as bars on the right
        const barX = w - 60;
        spectrum.forEach((val, i) => {
          const barY = spectroHeight - (i / spectrum.length) * spectroHeight;
          const barHeight = Math.max(1, spectroHeight / spectrum.length);
          const intensity = Math.min(255, val * 255);
          ctx.fillStyle = `rgba(${color === '#0f0' ? intensity + ',255,0' : '255,' + intensity + ',0'}, 0.9)`;
          ctx.fillRect(barX, barY, 50, barHeight);
        });
        
        // Draw frequency labels
        ctx.fillStyle = '#ccc';
        ctx.font = '10px monospace';
        const freqLabels = data.freq_labels || [];
        const step = Math.max(1, Math.floor(freqLabels.length / 6)); // Show ~6 labels
        for (let i = 0; i < freqLabels.length; i += step) {
          const y = spectroHeight - (i / freqLabels.length) * spectroHeight;
          ctx.fillText(freqLabels[i], 5, y + 5);
        }
      }
      
      // Draw level meter
      ctx.fillStyle = color;
      const levelHeight = Math.min(spectroHeight, (data.level || 0) * spectroHeight * 20);
      ctx.fillRect(barX + 55, spectroHeight - levelHeight, 15, levelHeight);
      
      // Labels and info
      ctx.fillStyle = '#fff';
      ctx.font = '12px monospace';
      ctx.fillText(label, 5, 15);
      ctx.fillText(`RMS: ${(data.level || 0).toFixed(4)}`, 5, h - 25);
      ctx.fillText(`Time →`, spectroWidth / 2, h - 5);
      ctx.fillText('Freq', barX + 10, h - 5);
    }

    function setVadModeUI(mode) {
      const clientBtn = document.getElementById('vadModeClient');
      const serverBtn = document.getElementById('vadModeServer');
      const clientParams = document.getElementById('clientVadParams');
      const serverInfo = document.getElementById('serverVadInfo');
      const currentMode = document.getElementById('currentVadMode');
      
      if (mode === 'server') {
        clientBtn.className = 'toggle';
        serverBtn.className = 'toggle ok';
        clientParams.style.display = 'none';
        serverInfo.style.display = 'block';
        if (currentMode) currentMode.textContent = 'Server VAD (OpenAI automatic)';
      } else {
        clientBtn.className = 'toggle ok';
        serverBtn.className = 'toggle';
        clientParams.style.display = 'block';
        serverInfo.style.display = 'none';
        if (currentMode) currentMode.textContent = 'Client VAD (Manual control)';
      }
    }

    function setVadMode(mode) {
      // Update UI
      setVadModeUI(mode);
      
      // Send to backend
      setParam('vad_mode', mode);
      
      // Show restart notice
      setTimeout(() => {
        alert('VAD mode changed. Click "Reload (Hard Reset)" in Main tab to apply.');
      }, 100);
    }
  </script>
  </head>
  <body>
    <h1>Robot Voice Control</h1>
    <div class="row">
      <button onclick="showTab('tabMain')">Main</button>
      <button onclick="showTab('tabSB'); sbLoad()">Soundboard</button>
      <button onclick="showTab('tabVoice'); voiceLoad()">Voice</button>
      <button onclick="showTab('tabControls'); controlsLoad()">Controls</button>
    </div>
    <div id="tabMain" class="tab" style="display:block">
    <div class="card">
      <h3>Microphone</h3>
      <div class="row">
        <button class="toggle" onclick="toggleMute()">Toggle Mute</button>
        <button class="ok" onclick="mute(false)">Unmute</button>
        <button class="danger" onclick="mute(true)">Mute</button>
      </div>
    </div>
    <br />
    <div class="card">
      <h3>Assistant</h3>
      <div class="row">
        <button onclick="stopSpeak()">Stop Speaking</button>
        <button class="danger" onclick="reloadAll()">Reload (Hard Reset)</button>
        <button class="toggle" onclick="audioReset()">Reset Audio</button>
      </div>
    </div>
    <br />
    <div class="card">
      <h3>Volume</h3>
      <div class="row">
        <label>Output Volume</label>
        <input type="range" min="0" max="100" value="100" oninput="setVolume(this.value)" />
        <span id="volLabel">100%</span>
      </div>
      <div class="row">
        <button onclick="volumeDown()">-10%</button>
        <button onclick="volumeUp()">+10%</button>
      </div>
    </div>
    <br />
    <div class="card">
      <h3>Interaction Behavior</h3>
      <div class="row">
        <label>Barge-in</label>
        <button onclick="setBargeIn(true)">Enable</button>
        <button onclick="setBargeIn(false)">Disable</button>
      </div>
      
    </div>
    <br />
    <div class="card">
      <h3>Recording</h3>
      <div class="row">
        <label>File name</label>
        <input id="recName" placeholder="optional, e.g. test.wav" />
        <button class="ok" onclick="recordStart()">Start</button>
        <button class="danger" onclick="recordStop()">Stop & Save</button>
      </div>
      <div class="row">
        <label>Saved files</label>
        <button onclick="refreshRecordings()">Refresh</button>
      </div>
      <ul id="recList"></ul>
    </div>
    <br />
    <div class="card">
      <h3>Upload WAV</h3>
      <div class="row">
        <input id="uploadFile" type="file" accept="audio/wav" />
        <button class="ok" onclick="uploadWav()">Upload</button>
      </div>
    </div>
    </div>
    </div>
    <div id="tabSB" class="tab" style="display:none">
      <div class="card">
        <h3>Soundboard</h3>
        <div class="row">
          <label>Profile</label>
          <select id="sbProfile" onchange="sbLoad()"></select>
          <button onclick="sbAddProfile()">Add Profile</button>
          <button class="ok" onclick="sbSave()">Save</button>
        </div>
        <div id="sbGrid" class="sb-grid"></div>
      </div>
    </div>
    <div id="tabVoice" class="tab" style="display:none">
      <div class="card">
        <h3>Voice Mode</h3>
        <div class="row">
          <label>Preset</label>
          <select id="voicePreset"></select>
          <button onclick="voiceApplyPreset()">Apply</button>
        </div>
        <div class="row">
          <label>persona.json</label>
          <textarea id="voicePersona" rows="12" style="width:100%; font-family:monospace"></textarea>
        </div>
        <div class="row">
          <label>facts.json</label>
          <textarea id="voiceFacts" rows="8" style="width:100%; font-family:monospace"></textarea>
        </div>
        <div class="row">
          <button class="ok" onclick="voiceSave()">Save</button>
        </div>
      </div>
    </div>
    <div id="tabControls" class="tab" style="display:none">
      <div class="card">
        <h3>VAD Mode</h3>
        <div class="row">
          <button id="vadModeClient" class="toggle" onclick="setVadMode('client')">Client VAD (Manual)</button>
          <button id="vadModeServer" onclick="setVadMode('server')">Server VAD (OpenAI)</button>
        </div>
        <div id="vadModeInfo" style="margin-top: 8px; padding: 8px; background: #f0f0f0; border-radius: 4px;">
          <strong>Client VAD:</strong> Manual control of speech detection using sliders below. More reliable timing control.<br>
          <strong>Server VAD:</strong> OpenAI handles speech detection automatically. Faster response, less control.
        </div>
      </div>
      <br />
      <div class="card">
        <h3>Audio Parameters</h3>
        <div id="clientVadParams">
          <div class="param-grid">
            <div class="param-box">
              <label>Hangover (ms): <span id="hangoverVal">500</span></label>
              <input type="range" min="0" max="2000" step="50" value="500" 
                     oninput="document.getElementById('hangoverVal').textContent=this.value; setParam('hangover', this.value)" />
              <small>How long mic stays muted after speaker stops</small>
            </div>
            <div class="param-box">
              <label>VAD Start Gate: <span id="vadStartVal">0.010</span></label>
              <input type="range" min="0.005" max="0.050" step="0.001" value="0.010" 
                     oninput="document.getElementById('vadStartVal').textContent=this.value; setParam('vad_start_gate', this.value)" />
              <small>Mic level threshold to start detecting speech</small>
            </div>
            <div class="param-box">
              <label>VAD Silence (ms): <span id="vadSilenceVal">2000</span></label>
              <input type="range" min="500" max="5000" step="100" value="2000" 
                     oninput="document.getElementById('vadSilenceVal').textContent=this.value; setParam('vad_silence', this.value)" />
              <small>How long to wait for silence before ending speech</small>
            </div>
          </div>
        </div>
        <div id="serverVadInfo" style="display:none; padding: 12px; background: #e8f5e8; border-radius: 4px;">
          Server VAD mode: OpenAI automatically detects when you start and stop speaking. Manual parameters above are ignored.
        </div>
      </div>
      <br />
      <div class="card">
        <h3>Live Microphone Visualization</h3>
        <div class="spectro-container">
          <div class="spectro-box">
            <canvas id="micSpectro" class="spectro-canvas" width="500" height="250"></canvas>
          </div>
        </div>
        <small>Real-time spectrogram: waterfall shows frequency over time, right bars show current spectrum, red lines show VAD thresholds.</small>
      </div>
    </div>
  </body>
  </html>



